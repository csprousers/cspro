#pragma once

#include <zToolsO/CSProException.h>

// for errors generated by repositories

// REPO_TODO: instead of passing CString messages, should we throw message numbers and then
// get them from the runtime strings (if possible)?

namespace DataRepositoryException
{
    class Error : public CSProException
    {
    protected:
        Error(const char* message, bool force_abort_on_startup = false)
            :   CSProException(message),
                m_forceAbortOnStartup(force_abort_on_startup)
        {
        }

        Error(const wchar_t* message, bool force_abort_on_startup = false)
            :   CSProException(message),
                m_forceAbortOnStartup(force_abort_on_startup)
        {
        }

        Error(const std::wstring& message, bool force_abort_on_startup = false)
            :   Error(message.c_str(), force_abort_on_startup)
        {
        }

    public:
        bool ForceAbortOnStartup() const { return m_forceAbortOnStartup; }

    private:
        const bool m_forceAbortOnStartup;
    };


#define CREATE_EXCEPTION_WITH_CUSTOM_MESSAGE_FULL(CLASS_NAME, FORCE_ABORT)            \
    struct CLASS_NAME : public Error                                                  \
    {                                                                                 \
        template<typename T>                                                          \
        CLASS_NAME(const T& message) : Error(message, FORCE_ABORT) { }                \
    };


#define CREATE_EXCEPTION_WITH_CUSTOM_MESSAGE(CLASS_NAME)                              \
    CREATE_EXCEPTION_WITH_CUSTOM_MESSAGE_FULL(CLASS_NAME, false)


#define CREATE_EXCEPTION_WITH_OPTIONAL_MESSAGE(CLASS_NAME, DEFAULT_MESSAGE)           \
    struct CLASS_NAME : public Error                                                  \
    {                                                                                 \
        CLASS_NAME()                     : Error(DEFAULT_MESSAGE) { }                 \
        CLASS_NAME(const TCHAR* message) : Error(message) { }                         \
    };


#define CREATE_EXCEPTION_WITH_DEFINED_MESSAGE_FULL(CLASS_NAME, MESSAGE, FORCE_ABORT)  \
    struct CLASS_NAME : public Error                                                  \
    {                                                                                 \
        CLASS_NAME() : Error(MESSAGE, FORCE_ABORT) { }                                \
    };


#define CREATE_EXCEPTION_WITH_DEFINED_MESSAGE(CLASS_NAME, MESSAGE)                    \
    CREATE_EXCEPTION_WITH_DEFINED_MESSAGE_FULL(CLASS_NAME, MESSAGE, false)


#define CREATE_IOERROR_EXCEPTION_WITH_DEFINED_MESSAGE(CLASS_NAME, MESSAGE)            \
    struct CLASS_NAME : public IOError                                                \
    {                                                                                 \
        CLASS_NAME() : IOError(MESSAGE) { }                                           \
    };


#define CREATE_PROGRAMMING_ERROR_EXCEPTION_WITH_DEFINED_MESSAGE(CLASS_NAME, MESSAGE)  \
    struct CLASS_NAME : public Error                                                  \
    {                                                                                 \
        CLASS_NAME()                                                                  \
            :   Error(MESSAGE)                                                        \
        {                                                                             \
            ASSERT(false);                                                            \
        }                                                                             \
    };


    CREATE_EXCEPTION_WITH_CUSTOM_MESSAGE(IOError)
    CREATE_IOERROR_EXCEPTION_WITH_DEFINED_MESSAGE(GenericReadError, "There was an error reading from the data source.")
    CREATE_IOERROR_EXCEPTION_WITH_DEFINED_MESSAGE(GenericWriteError, "There was an error writing to the data source.")
    CREATE_IOERROR_EXCEPTION_WITH_DEFINED_MESSAGE(DeleteRepositoryError, "There was an error deleting the data source.")
    CREATE_IOERROR_EXCEPTION_WITH_DEFINED_MESSAGE(RenameRepositoryError, "There was an error renaming the data source.")
    CREATE_EXCEPTION_WITH_CUSTOM_MESSAGE(DuplicateCaseWhileCreatingIndex)
    CREATE_EXCEPTION_WITH_DEFINED_MESSAGE(CaseNotFound, "The case could not be found.")
    CREATE_EXCEPTION_WITH_DEFINED_MESSAGE(IndexRequired, "The data source requires an index to execute the requested operation.")
    CREATE_EXCEPTION_WITH_OPTIONAL_MESSAGE(SQLiteError, "There was an error communicating with the SQLite database.")
    CREATE_PROGRAMMING_ERROR_EXCEPTION_WITH_DEFINED_MESSAGE(WriteAccessRequired, "The data source requires write access to execute the requested operation.")
    CREATE_PROGRAMMING_ERROR_EXCEPTION_WITH_DEFINED_MESSAGE(NotValidInBatchOutput, "The requested operation is not available for a batch output file.")
    CREATE_EXCEPTION_WITH_CUSTOM_MESSAGE_FULL(DictionaryChanged, true)
    CREATE_EXCEPTION_WITH_CUSTOM_MESSAGE_FULL(EncryptionError, true)

#undef CREATE_PROGRAMMING_ERROR_EXCEPTION_WITH_DEFINED_MESSAGE
#undef CREATE_IOERROR_EXCEPTION_WITH_DEFINED_MESSAGE
#undef CREATE_EXCEPTION_WITH_DEFINED_MESSAGE
#undef CREATE_EXCEPTION_WITH_DEFINED_MESSAGE_FULL
#undef CREATE_EXCEPTION_WITH_CUSTOM_MESSAGE
#undef CREATE_EXCEPTION_WITH_CUSTOM_MESSAGE_FULL
}
