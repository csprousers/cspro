#include "StdAfx.h"
#include "FrequencyTableCreatorFromTableGridExporter.h"
#include <zJson/Json.h>
#include <zFreqO/FrequencyTable.h>
#include <zFreqO/FrequencyPrinterHelpers.h>
#include <sstream>


FrequencyTableCreatorFromTableGridExporter::FrequencyTableCreatorFromTableGridExporter()
    :   m_currentFrequencyRow(nullptr)
{
}


FrequencyTableCreatorFromTableGridExporter::~FrequencyTableCreatorFromTableGridExporter()
{
}


std::wstring FrequencyTableCreatorFromTableGridExporter::CreateFrequencyJson(CTblGrid& table_grid)
{
    m_titles.reset();

    std::wstringstream os;
    table_grid.PutTable(*this, os, false);

    ASSERT(m_frequencyTable != nullptr);

    auto json_writer = Json::CreateStringWriter();

    json_writer->Write(*m_frequencyTable);

    return json_writer->GetString();
}


void FrequencyTableCreatorFromTableGridExporter::StartFile(_tostream& /*os*/)
{
}


void FrequencyTableCreatorFromTableGridExporter::EndFile(_tostream& /*os*/)
{
}


void FrequencyTableCreatorFromTableGridExporter::StartFormats(_tostream& /*os*/)
{
}


void FrequencyTableCreatorFromTableGridExporter::WriteFormat(_tostream& /*os*/, const CFmt& /*fmt*/)
{
}


void FrequencyTableCreatorFromTableGridExporter::EndFormats(_tostream& /*os*/)
{
}
    

void FrequencyTableCreatorFromTableGridExporter::StartTable(_tostream& /*os*/, int /*iNumCols*/)
{
}


void FrequencyTableCreatorFromTableGridExporter::StartHeaderRows(_tostream& /*os*/)
{
}


void FrequencyTableCreatorFromTableGridExporter::EndHeaderRows(_tostream& /*os*/)
{
}


void FrequencyTableCreatorFromTableGridExporter::EndTable(_tostream& /*os*/)
{
}
    

void FrequencyTableCreatorFromTableGridExporter::WriteTitle(_tostream& /*os*/, const CFmt& /*fmt*/, const CString& sTitle)
{
    ASSERT(m_titles == nullptr);
    m_titles = std::make_unique<std::vector<std::wstring>>();

    SO::ForeachLine(sTitle, true,
        [&](const wstring_view title_sv)
        {
            m_titles->emplace_back(title_sv);
            return true;
        });
}


void FrequencyTableCreatorFromTableGridExporter::WriteSubTitle(_tostream& /*os*/, const CFmt& /*fmt*/, const CString& /*sSubTitle*/)
{
}
    

void FrequencyTableCreatorFromTableGridExporter::StartRow(_tostream& /*os*/, int /*iRow*/, const CDWordArray& /*aRowHeaders*/)
{
}


void FrequencyTableCreatorFromTableGridExporter::EndRow(_tostream& /*os*/)
{
    if( m_frequencyTable == nullptr )
        throw CreationException();
}


bool FrequencyTableCreatorFromTableGridExporter::IgnoreFormatting()
{
    return true;
}


void FrequencyTableCreatorFromTableGridExporter::WriteCell(_tostream& /*os*/, int iCol, int iRow, const CFmt& /*fmt*/, const CString& sCellData, const CJoinRegion& join, const CArray<CJoinRegion>& /*aColHeaders*/)
{
    // header row handling
    if( iRow == 0 )
    {
        if( m_frequencyTable == nullptr )
        {
            m_frequencyTable = std::make_unique<FrequencyTable>();

            // set the title
            if( m_titles != nullptr )
            {
                m_frequencyTable->titles = std::move(*m_titles);
                m_titles.reset();
            }
        }

        // set the symbol name
        if( iCol == 0 )
        {
            m_frequencyTable->symbol_name = CS2WS(sCellData);
        }

        // make sure the first column matches that generated by frequency tables
        else if( iCol == 1 && !SO::Equals(sCellData, FPH::FrequencyLabel) )
        {
            throw CreationException();
        }

        return;
    }

    // the second row should not be data either
    else if( iRow == 1 )
    {
        if( ( iCol == 1 && !SO::Equals(sCellData, FPH::TotalLabel) ) ||
            ( iCol == 2 && !SO::Equals(sCellData, FPH::PercentLabel) ) )
        {
            throw CreationException();
        }

        return;
    }

    // row data handling
    ASSERT(iRow >= 2 && m_frequencyTable != nullptr);

    // on the first column of the data...
    if( iCol == 0 )
    {
        // ...ignore the row if it is the total row
        if( SO::Equals(sCellData, FPH::TotalLabel) )
        {
            m_currentFrequencyRow = nullptr;
        }

        // ...ignore the row if the first column spans multiple columns (e.g., the statistics row)
        else if( join.iStartCol != join.iEndCol )
        {
            m_currentFrequencyRow = nullptr;
        }

        // ...or create a new frequency row
        else
        {
            m_currentFrequencyRow = &m_frequencyTable->frequency_rows.emplace_back();
            m_currentFrequencyRow->display_label = CS2WS(sCellData);

            // this is unused, but the count of these must match the number of frequency rows
            m_frequencyTable->frequency_row_statistics.emplace_back();
        }

        return;
    }

    // frequency data handling
    if( m_currentFrequencyRow != nullptr && iCol == 1 )
    {
        // remove any commas from the text and then convert to a number
        std::wstring cell_data = SO::Trim(sCellData);
        SO::Remove(cell_data, ',');

        try
        {
            size_t post_value_pos;
            m_currentFrequencyRow->count = std::stod(cell_data, &post_value_pos);

            if( post_value_pos != cell_data.length() )
                throw CreationException();
        }

        catch(...)
        {
            throw CreationException();
        }
    }
}
