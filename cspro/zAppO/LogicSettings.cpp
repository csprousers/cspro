#include "stdafx.h"
#include "LogicSettings.h"
#include <zToolsO/WinSettings.h>


CREATE_JSON_KEY(accessFromExternalCaller)
CREATE_JSON_KEY(accessTokens)
CREATE_JSON_KEY(actionInvoker)
CREATE_JSON_KEY(convertResultsForLogic)

CREATE_ENUM_JSON_SERIALIZER(LogicSettings::ActionInvokerAccessFromExternalCaller,
    { LogicSettings::ActionInvokerAccessFromExternalCaller::AlwaysAllow,                _T("alwaysAllow") },
    { LogicSettings::ActionInvokerAccessFromExternalCaller::PromptIfNoValidAccessToken, _T("promptIfNoValidAccessToken") },
    { LogicSettings::ActionInvokerAccessFromExternalCaller::RequireAccessToken,         _T("requireAccessToken") })


const std::wstring LogicSettings::m_singleLineComment(CommentStrings::SingleLine);
const std::tuple<const std::wstring, const std::wstring> LogicSettings::m_multilineCommentNew(CommentStrings::MultilineNewStart, CommentStrings::MultilineNewEnd);
const std::tuple<const std::wstring, const std::wstring> LogicSettings::m_multilineCommentOld(CommentStrings::MultilineOldStart, CommentStrings::MultilineOldEnd);

namespace
{
    constexpr double VersionNumbers[] = { 2.0, 8.0 };
}


LogicSettings::LogicSettings(const Version version/* = Version::V0*/)
    :   m_version(version),
        m_caseSensitiveSymbols(false),
        m_actionInvokerAccessFromExternalCaller(ActionInvokerAccessFromExternalCaller::PromptIfNoValidAccessToken),
        m_actionInvokerConvertResults(true)
{
    // the default settings match the settings up to CSPro 8.0
}


LogicSettings LogicSettings::GetUserDefaultSettings()
{
    // load the default settings from the registry, and on error, return the original settings
#ifdef WIN_DESKTOP
    try
    {
        const std::wstring json_text = WinSettings::Read<std::wstring>(WinSettings::Type::LogicSettings);

        if( !json_text.empty() )
            return CreateFromJson(Json::Parse(json_text));
    }
    catch(...) { }
#endif

    return GetOriginalSettings();
}


bool LogicSettings::operator==(const LogicSettings& rhs) const
{
    return ( m_version == rhs.m_version &&
             m_caseSensitiveSymbols == rhs.m_caseSensitiveSymbols &&
             m_actionInvokerAccessFromExternalCaller == rhs.m_actionInvokerAccessFromExternalCaller &&
             m_actionInvokerAccessTokens == rhs.m_actionInvokerAccessTokens &&
             m_actionInvokerConvertResults == rhs.m_actionInvokerConvertResults );
}


// --------------------------------------------------------------------------
// default line methods
// --------------------------------------------------------------------------

std::wstring LogicSettings::GetDefaultFirstLineForTextSource(const NullTerminatedString application_label, const AppFileType app_file_type) const
{
    ASSERT(app_file_type == AppFileType::Code || app_file_type == AppFileType::Message);

    return FormatTextCS2WS(_T("%s Application '%s' %s file generated by CSPro %s\n"),
                           GetMultilineCommentStart().c_str(),
                           application_label.c_str(),
                           ( app_file_type == AppFileType::Code ) ? _T("logic") : _T("message"),
                           GetMultilineCommentEnd().c_str());
}


std::wstring LogicSettings::GetGeneratedCodeTextForTextSource() const
{
    return FormatTextCS2WS(_T("%s Generated Code %s"),
                           GetMultilineCommentStart().c_str(),
                           GetMultilineCommentEnd().c_str());
}


// --------------------------------------------------------------------------
// serialization
// --------------------------------------------------------------------------

LogicSettings LogicSettings::CreateFromJson(const JsonNode<wchar_t>& json_node)
{
    LogicSettings logic_settings;

    std::optional<double> version_number = json_node.GetOptional<double>(JK::version);

    for( size_t i = 0; version_number.has_value() && i < _countof(VersionNumbers); ++i )
    {
        if( *version_number == VersionNumbers[i] )
        {
            logic_settings.m_version = static_cast<Version>(i);
            version_number.reset();
        }
    }

    if( version_number.has_value() )
        json_node.LogWarning(_T("'%0.1f' is not a valid logic version"), *version_number);

    if( json_node.Contains(JK::caseSensitive) )
    {
        const auto case_sensitive_node = json_node.Get(JK::caseSensitive);
        logic_settings.m_caseSensitiveSymbols = case_sensitive_node.GetOrDefault(JK::symbols, logic_settings.m_caseSensitiveSymbols);
    }

    if( json_node.Contains(JK::actionInvoker) )
    {
        const auto action_invoker_node = json_node.Get(JK::actionInvoker);
        logic_settings.m_actionInvokerAccessFromExternalCaller = action_invoker_node.GetOrDefault(JK::accessFromExternalCaller, logic_settings.m_actionInvokerAccessFromExternalCaller);
        logic_settings.m_actionInvokerAccessTokens = action_invoker_node.GetOrDefault(JK::accessTokens, logic_settings.m_actionInvokerAccessTokens);
        logic_settings.m_actionInvokerConvertResults = action_invoker_node.GetOrDefault(JK::convertResultsForLogic, logic_settings.m_actionInvokerConvertResults);
    }

    return logic_settings;
}


void LogicSettings::WriteJson(JsonWriter& json_writer) const
{
    json_writer.BeginObject()
               .Write(JK::version, VersionNumbers[static_cast<size_t>(m_version)]);

    json_writer.Key(JK::caseSensitive).WriteObject(
        [&]()
        {
            json_writer.Write(JK::symbols, m_caseSensitiveSymbols);
        });

    json_writer.Key(JK::actionInvoker).WriteObject(
        [&]()
        {
            json_writer.Write(JK::accessFromExternalCaller, m_actionInvokerAccessFromExternalCaller)
                       .WriteIfNotEmpty(JK::accessTokens, m_actionInvokerAccessTokens)
                       .Write(JK::convertResultsForLogic, m_actionInvokerConvertResults);
        });

    json_writer.EndObject();
}


void LogicSettings::serialize(Serializer& ar)
{
    ar.SerializeEnum(m_version);
    ar & m_caseSensitiveSymbols;
    ar.SerializeEnum(m_actionInvokerAccessFromExternalCaller);
    ar & m_actionInvokerAccessTokens
       & m_actionInvokerConvertResults;
}
