#define WIN_DESKTOP
#include <engine/StandardSystemIncludes.h>
#include <engine/StrictCompilerErrors.h>
#include "jsmin.h"
#include <zToolsO/Encoders.h>
#include <zToolsO/FileIO.h>
#include <zToolsO/Hash.h>
#include <zToolsO/Utf8Convert.h>
#include <zJson/JsonSpecFile.h>
#include <zAction/ActionInvoker.h>
#include <zLogicO/GeneralizedFunction.h>


// to avoid frequently modifying FunctionTable.h, which causes a lot of files to be rebuilt, 
// this flag controls whether to update function namespace table, which will be a rare occurrence
constexpr bool UpdateFunctionTableHeaderFile = false;


constexpr const wchar_t* ActionInvokerBaseNamespace = L"CS";

constexpr std::wstring_view AutogeneratedStart_sv = L"// --- CS_AUTOGENERATED_START";
constexpr std::wstring_view AutogeneratedEnd_sv   = L"// --- CS_AUTOGENERATED_END";

constexpr const wchar_t* TabSpacing1   = L"    ";
constexpr const wchar_t* TabSpacing2   = L"        ";
constexpr const wchar_t* TabSpacing3   = L"            ";
constexpr const wchar_t* LineSeparator = L"// --------------------------------------------------------------------------";

constexpr std::string_view HashSalt_sv = "CS";
using HashType                         = unsigned short;
constexpr size_t HashLength            = sizeof(HashType);
constexpr size_t HashIterations        = 1024;


struct ActionInfo : public GF::Function
{
    const int hash;

    ActionInfo(const GF::Function& action_definition);

    std::wstring GetNamespaceAndName(wchar_t separator) const;
    std::wstring GetActionEnumClassId(bool name_only) const;
    std::wstring GetFunctionNamespaceEnumClassId(wchar_t separator) const;
    std::wstring GetHelpFilename() const;
    std::wstring GetActionInvokerMethodName() const;

private:
    int CalculateHash() const;
};


std::wstring CreateActionEnumText(const std::vector<ActionInfo>& action_infos);

std::wstring ConstructParameterText(const std::vector<GF::Parameter>& parameters);

std::wstring CreateFunctionTableText(const std::vector<ActionInfo>& action_infos);
std::wstring CreateJsonFunctionDefinitionsText(const std::vector<ActionInfo>& action_infos);

std::wstring CreateFunctionNamespaceEnumText(const std::vector<ActionInfo>& action_infos);

std::wstring CreateFunctionNamespaceDetailsText(const std::vector<ActionInfo>& action_infos);

std::wstring CreateFunctionDeclarationsText(const std::vector<ActionInfo>& action_infos);

std::wstring CreateFunctionMappingText(const std::vector<ActionInfo>& action_infos);

void CreateActionInvokerJavaScript(const std::vector<ActionInfo>& action_infos, const std::wstring& template_filename, std::initializer_list<std::wstring> output_filenames);

void ReplaceAutogeneratedRegion(const std::wstring& filename, std::initializer_list<std::wstring> replacement_texts);
void ReplaceAutogeneratedRegion(std::wstring& file_text, std::wstring replacement_text, const std::wstring& autogenerated_start_text, const std::wstring& autogenerated_end_text);


int wmain(int argc, wchar_t* argv[])
{
    try
    {
        if( argc < 2 )
            throw CSProException("Specify the location of the CSPro code directory.");

        const std::wstring code_directory = MakeFullPath(GetWorkingFolder(), argv[1]);
        const std::wstring zAction_directory = PortableFunctions::PathAppendToPath(code_directory, L"zAction");
        const std::wstring zLogicO_directory = PortableFunctions::PathAppendToPath(code_directory, L"zLogicO");
        const std::wstring html_directory_windows = PortableFunctions::PathAppendToPath(code_directory, L"html");
        const std::wstring html_directory_android = PortableFunctions::PathAppendToPath(code_directory, LR"!(CSEntryDroid\app\src\main\assets\html)!");
        const std::wstring definitions_filename = PortableFunctions::PathAppendToPath(zAction_directory, L"action-definitions.json");

        // read the definitions...
        std::vector<GF::Function> action_definitions =
            [&]()
            {
                auto json_reader = JsonSpecFile::CreateReader(definitions_filename);
                return json_reader->GetArray().GetVector<GF::Function>();
            }();

        // ...sort by action namespace and name
        std::sort(action_definitions.begin(), action_definitions.end(),
            [&](const GF::Function& gf1, const GF::Function& gf2) 
            { 
                const int namespace_comparison = SO::CompareNoCase(gf1.namespace_name, gf2.namespace_name);
                return ( namespace_comparison != 0 ) ? ( namespace_comparison < 0 ) :
                                                       ( SO::CompareNoCase(gf1.name, gf2.name) < 0 );                                                    
            });

        // ...and resave the actions
        {
            auto json_writer = Json::CreateFileWriter(definitions_filename);
            json_writer->Write(action_definitions);
        }


        // create the ActionInfo object for each action, which will create the action hashes
        std::vector<ActionInfo> action_infos;

        for( const GF::Function& action_definition : action_definitions )
            action_infos.emplace_back(action_definition);

        // write the ActionInvoker::Action enum class with associated hash values to zLogicO/ActionInvoker.h
        ReplaceAutogeneratedRegion(PortableFunctions::PathAppendToPath(zLogicO_directory, L"ActionInvoker.h"), { CreateActionEnumText(action_infos) });

        // write the function table and definitions to zLogicO/ActionInvoker.cpp
        ReplaceAutogeneratedRegion(PortableFunctions::PathAppendToPath(zLogicO_directory, L"ActionInvoker.cpp"), { CreateFunctionTableText(action_infos),
                                                                                                                   CreateJsonFunctionDefinitionsText(action_infos) });

        // write the FunctionNamespace enum class to zLogicO/FunctionTable.h
        if( UpdateFunctionTableHeaderFile )
            ReplaceAutogeneratedRegion(PortableFunctions::PathAppendToPath(zLogicO_directory, L"FunctionTable.h"), { CreateFunctionNamespaceEnumText(action_infos) });

        // write the FunctionNamespace details to zLogicO/FunctionTable.cpp
        ReplaceAutogeneratedRegion(PortableFunctions::PathAppendToPath(zLogicO_directory, L"FunctionTable.cpp"), { CreateFunctionNamespaceDetailsText(action_infos) });

        // write the function declarations to zAction/ActionInvoker.h
        ReplaceAutogeneratedRegion(PortableFunctions::PathAppendToPath(zAction_directory, L"ActionInvoker.h"), { CreateFunctionDeclarationsText(action_infos) });

        // write the functions to the function mapping in zAction/ActionFunctionMapping.cpp
        ReplaceAutogeneratedRegion(PortableFunctions::PathAppendToPath(zAction_directory, L"ActionFunctionMapping.cpp"), { CreateFunctionMappingText(action_infos) });

        // create the JavaScript files for the Windows and Android environments
        CreateActionInvokerJavaScript(action_infos, PortableFunctions::PathAppendToPath(zAction_directory, L"action-invoker-template.js"),
            { 
                PortableFunctions::PathAppendToPath(html_directory_windows, L"action-invoker.js"),
                PortableFunctions::PathAppendToPath(html_directory_android, L"action-invoker.js"),
            });
    }

    catch( const CSProException& exception )
    {
        MessageBoxW(nullptr, exception.GetErrorMessage().c_str(), L"Action Invoker Definition Updater", MB_OK | MB_ICONEXCLAMATION);
    }
}



// --------------------------------------------------------------------------
// ActionInfo
// --------------------------------------------------------------------------

ActionInfo::ActionInfo(const GF::Function& action_definition)
    :   GF::Function(action_definition),
        hash(CalculateHash())
{
}


int ActionInfo::CalculateHash() const
{
    const std::string action_name_utf8 = UTF8Convert::WideToUTF8(GetNamespaceAndName('.'));

    const std::vector<std::byte> hash_data = Hash::Hash(reinterpret_cast<const std::byte*>(action_name_utf8.data()), action_name_utf8.length(),
                                                        reinterpret_cast<const std::byte*>(HashSalt_sv.data()), HashSalt_sv.length(),
                                                        HashLength, HashIterations);
    ASSERT(hash_data.size() == sizeof(HashType));
    static_assert(sizeof(HashType) < sizeof(int));

    const int calculated_hash = *reinterpret_cast<const HashType*>(hash_data.data());
    ASSERT(calculated_hash >= 0);

    return calculated_hash;
}


std::wstring ActionInfo::GetNamespaceAndName(const wchar_t separator) const
{
    if( namespace_name.empty() )
        return name;
    
    return namespace_name + separator + name;    
}


std::wstring ActionInfo::GetActionEnumClassId(const bool name_only) const
{
    std::wstring id = GetActionInvokerMethodName();

    if( name_only )
        return id;
    
    return L"ActionInvoker::Action::" + id;
}


std::wstring ActionInfo::GetFunctionNamespaceEnumClassId(const wchar_t separator) const
{
    if( namespace_name.empty() )
        return ActionInvokerBaseNamespace;
    
    return std::wstring(ActionInvokerBaseNamespace) + separator + namespace_name;
}


std::wstring ActionInfo::GetHelpFilename() const
{
    return FormatTextCS2WS(L"%s_%s.html", GetFunctionNamespaceEnumClassId('_').c_str(), name.c_str());
}


std::wstring ActionInfo::GetActionInvokerMethodName() const
{
    return GetNamespaceAndName('_');
}



// --------------------------------------------------------------------------
// other functions
// --------------------------------------------------------------------------

std::wstring CreateActionEnumText(const std::vector<ActionInfo>& action_infos)
{
    struct EnumNameAndHashCode
    {
        std::wstring enum_name;
        std::wstring hash_code;
    };

    std::vector<EnumNameAndHashCode> enum_name_and_hash_codes;
    size_t longest_enum_name = 0;
    size_t longest_hash_code = 0;
    std::set<int> already_calculated_hashes;

    for( const ActionInfo& action_info : action_infos )
    {
        const EnumNameAndHashCode& enum_name_and_hash_code = enum_name_and_hash_codes.emplace_back(
            EnumNameAndHashCode { action_info.GetActionEnumClassId(true), CS2WS(IntToString(action_info.hash)) });

        longest_enum_name = std::max(longest_enum_name, enum_name_and_hash_code.enum_name.length());
        longest_hash_code = std::max(longest_hash_code, enum_name_and_hash_code.hash_code.length());

        // make sure each hash is unique
        if( already_calculated_hashes.find(action_info.hash) != already_calculated_hashes.cend() )
            throw CSProException(L"The hash code %d is duplicated", action_info.hash);

        already_calculated_hashes.insert(action_info.hash);
    }

    // generate the enum class
    std::wstring action_enum_text;

    for( const EnumNameAndHashCode& enum_name_and_hash_code : enum_name_and_hash_codes )
    {
        const size_t enum_name_spacing = longest_enum_name - enum_name_and_hash_code.enum_name.length();
        const size_t hash_code_spacing = longest_hash_code - enum_name_and_hash_code.hash_code.length();

        SO::AppendFormat(action_enum_text, L"%s%s%*s = %*s%s,\n", TabSpacing2,
                                           enum_name_and_hash_code.enum_name.c_str(), static_cast<int>(enum_name_spacing), L"",
                                           static_cast<int>(hash_code_spacing), L"", enum_name_and_hash_code.hash_code.c_str());
    }

    return action_enum_text;
}


std::wstring ConstructParameterText(const std::vector<GF::Parameter>& parameters)
{
    std::wstring parameter_text;
    std::vector<const GF::Parameter*> not_required_parameters;

    auto get_parameter_text = [&](const GF::Parameter& parameter)
    {
        ASSERT(!parameter.variable.types.empty());

        std::wstring parameter_text = FormatTextCS2WS(L"%s := %s", parameter.variable.name.c_str(), ToString(parameter.variable.types.front()));

        for( size_t i = 1; i < parameter.variable.types.size(); ++i )
            SO::Append(parameter_text, L" | ", ToString(parameter.variable.types[i]));

        return parameter_text;
    };

    // add required parameters
    for( const GF::Parameter& parameter : parameters )
    {
        if( parameter.required )
        {
            SO::AppendWithSeparator(parameter_text, get_parameter_text(parameter), L", ");
        }

        else
        {
            not_required_parameters.emplace_back(&parameter);
        }
    }

    // add not-required parameters
    if( !not_required_parameters.empty() )
    {
        const auto not_required_parameters_cend = not_required_parameters.cend();

        for( auto not_required_parameters_itr = not_required_parameters.cbegin();
             not_required_parameters_itr != not_required_parameters_cend;
             ++not_required_parameters_itr )
        {
            parameter_text.append(( not_required_parameters_itr != not_required_parameters.cbegin() ) ? L", " :
                                  ( parameter_text.empty() )                                          ? L"[" :
                                                                                                        L"[, ");
            parameter_text.append(get_parameter_text(*(*not_required_parameters_itr)));
        }

        parameter_text.push_back(']');
    }

    return parameter_text;
}


std::wstring CreateFunctionTableText(const std::vector<ActionInfo>& action_infos)
{
    std::wstring function_table_text;
    std::optional<std::wstring> previous_namespace_name;

    for( const ActionInfo& action_info : action_infos )
    {
        if( previous_namespace_name != action_info.namespace_name )
        {
            if( previous_namespace_name.has_value() )
                SO::Append(function_table_text, L"\n\n");

            SO::AppendFormat(function_table_text, L"%s%s\n%s// %s functions\n%s%s\n", 
                                                  TabSpacing2, LineSeparator,
                                                  TabSpacing2, action_info.GetFunctionNamespaceEnumClassId('.').c_str(),
                                                  TabSpacing2, LineSeparator);
            
            previous_namespace_name = action_info.namespace_name;
        }

        SO::AppendFormat(function_table_text, L"%s{\n", TabSpacing2);
        SO::AppendFormat(function_table_text, L"%s_T(\"%s\"),\n", TabSpacing3, action_info.name.c_str());
        SO::AppendFormat(function_table_text, L"%s_T(\"%s.%s(%s)\"),\n", TabSpacing3, ActionInvokerBaseNamespace, action_info.GetNamespaceAndName('.').c_str(), ConstructParameterText(action_info.parameters).c_str());
        SO::AppendFormat(function_table_text, L"%s_T(\"%s\"),\n", TabSpacing3, action_info.GetHelpFilename().c_str());
        SO::AppendFormat(function_table_text, L"%sFunctionCode::CSFN_ACTIONINVOKER_CODE,\n", TabSpacing3);
        SO::AppendFormat(function_table_text, L"%sFunctionNamespace::%s,\n", TabSpacing3, action_info.GetFunctionNamespaceEnumClassId('_').c_str());
        SO::AppendFormat(function_table_text, L"%sDataType::String,\n", TabSpacing3);
        SO::AppendFormat(function_table_text, L"%sFunctionCompilationType::CS,\n", TabSpacing3);
        SO::AppendFormat(function_table_text, L"%sstatic_cast<int>(%s),\n", TabSpacing3, action_info.GetActionEnumClassId(false).c_str());
        SO::AppendFormat(function_table_text, L"%s},\n", TabSpacing2);
    }

    return function_table_text;
}


std::wstring CreateJsonFunctionDefinitionsText(const std::vector<ActionInfo>& action_infos)
{
    std::vector<std::wstring> enum_names;
    size_t longest_enum_name = 0;

    for( const ActionInfo& action_info : action_infos )
    {
        const std::wstring& enum_name = enum_names.emplace_back(action_info.GetActionEnumClassId(false));
        longest_enum_name = std::max(longest_enum_name, enum_name.length());
    }

    std::wstring json_function_definitions_text;
    auto enum_names_itr = enum_names.cbegin();    

    for( const ActionInfo& action_info : action_infos )
    {
        auto json_writer = Json::CreateStringWriter(JsonFormattingOptions::Compact);
        json_writer->Write(action_info);

        size_t enum_name_spacing = longest_enum_name - enum_names_itr->length();

        SO::AppendFormat(json_function_definitions_text, L"%s{ %s,%*s _T(\"%s\") },\n", TabSpacing2,
                                                         enum_names_itr->c_str(),
                                                         static_cast<int>(enum_name_spacing), L"",
                                                         Encoders::ToEscapedString(json_writer->c_str(), false).c_str());

        ++enum_names_itr;
    } 

    return json_function_definitions_text;
}


std::wstring CreateFunctionNamespaceEnumText(const std::vector<ActionInfo>& action_infos)
{
    std::wstring function_namespace_enum_text;
    std::optional<std::wstring> previous_enum_name;

    for( const ActionInfo& action_info : action_infos )
    {
        std::wstring enum_name = action_info.GetFunctionNamespaceEnumClassId('_');
        
        if( previous_enum_name != enum_name )
        {
            SO::AppendFormat(function_namespace_enum_text, L"%s%s,\n", TabSpacing2, enum_name.c_str());
            previous_enum_name = std::move(enum_name);
        }
    }

    return function_namespace_enum_text;
}


std::wstring CreateFunctionNamespaceDetailsText(const std::vector<ActionInfo>& action_infos)
{
    std::wstring function_namespace_details_text;
    std::optional<std::wstring> previous_enum_name;
    constexpr size_t longest_namespace_name = 11;
    constexpr size_t longest_enum_name = 14;
    constexpr size_t longest_parent_function_namespace = 22;
    constexpr size_t longest_help_filename = 19;

    for( const ActionInfo& action_info : action_infos )
    {
        const std::wstring namespace_name = action_info.namespace_name.empty() ? ActionInvokerBaseNamespace : 
                                                                                 action_info.namespace_name;
        const std::wstring enum_name = action_info.GetFunctionNamespaceEnumClassId('.');

        if( previous_enum_name != enum_name )
        {
            const std::wstring parent_function_namespace = action_info.namespace_name.empty() ? L"std::nullopt" : 
                                                                                                SO::Concatenate(L"FunctionNamespace::", ActionInvokerBaseNamespace); 

            const std::wstring help_filename = action_info.namespace_name.empty() ? _T("action_invoker.html") :
                                                                                    ( action_info.GetFunctionNamespaceEnumClassId('_') + _T(".html") );

            auto get_spacing_length = [&](const size_t longest_value, const std::wstring& text) -> int
            {
                if( longest_value < text.length() )
                    throw CSProException("Increase the spacing of FunctionNamespaces");

                return static_cast<int>(longest_value - text.length());
            };
            
            SO::AppendFormat(function_namespace_details_text,  L"%s{ _T(\"%s\"),%*s FunctionNamespace::%s,%*s %s,%*s _T(\"%s\")%*s },\n", TabSpacing2, 
                                                               namespace_name.c_str(), get_spacing_length(longest_namespace_name, namespace_name), L"",
                                                               action_info.GetFunctionNamespaceEnumClassId('_').c_str(), get_spacing_length(longest_enum_name, enum_name), L"",
                                                               parent_function_namespace.c_str(), get_spacing_length(longest_parent_function_namespace, parent_function_namespace), L"",
                                                               help_filename.c_str(), get_spacing_length(longest_help_filename, help_filename), L"");

            previous_enum_name = enum_name;
        }
    }

    return function_namespace_details_text;
}


std::wstring CreateFunctionDeclarationsText(const std::vector<ActionInfo>& action_infos)
{
    std::wstring function_declarations_text;

    for( const ActionInfo& action_info : action_infos )
        SO::AppendFormat(function_declarations_text, L"%sResult %s(const JsonNode<wchar_t>& json_node, Caller& caller);\n", TabSpacing2, action_info.GetActionInvokerMethodName().c_str());

    return function_declarations_text;
}


std::wstring CreateFunctionMappingText(const std::vector<ActionInfo>& action_infos)
{
    std::wstring function_mapping_text;
    std::vector<std::wstring> method_names;
    size_t longest_method_name = 0;
    
    for( const ActionInfo& action_info : action_infos )
    {
        const std::wstring& method_name = method_names.emplace_back(action_info.GetActionInvokerMethodName());
        longest_method_name = std::max(longest_method_name, method_name.length());
    }

    for( const std::wstring& method_name : method_names )
    {
        const size_t method_name_spacing = longest_method_name - method_name.length();

        SO::AppendFormat(function_mapping_text, L"%s{ Action::%s,%*s &Runtime::%s%*s },\n", TabSpacing1,
                                                method_name.c_str(), static_cast<int>(method_name_spacing), L"",
                                                method_name.c_str(), static_cast<int>(method_name_spacing), L"");
    }

    return function_mapping_text;
}


void CreateActionInvokerJavaScript(const std::vector<ActionInfo>& action_infos, const std::wstring& template_filename, const std::initializer_list<std::wstring> output_filenames)
{
    std::wstring js_text = FileIO::ReadText(template_filename);
    SO::Replace(js_text, L"\r\n", L"\n");

    std::wstring functions_text = _T("\n");

    std::optional<std::wstring> previous_namespace_name;
    std::optional<size_t> in_namespace_action_index;

    auto end_namespace_if_necessary = [&]()
    {
        if( in_namespace_action_index.has_value() )
        {
            ASSERT(*in_namespace_action_index > 0);
            SO::Append(functions_text, L"\n};\n");
            in_namespace_action_index.reset();
        }
    };

    for( const ActionInfo& action_info : action_infos )
    {
        if( previous_namespace_name != action_info.namespace_name )
        {
            end_namespace_if_necessary();

            if( !action_info.namespace_name.empty() )
            {
                SO::AppendFormat(functions_text, L"\n%s = {\n", action_info.namespace_name.c_str());
                in_namespace_action_index = 0;
            }
            
            previous_namespace_name = action_info.namespace_name;
        }

        auto get_function_body = [&](const bool async)
        {
            return FormatTextCS2WS(L"{return CSProActionInvoker.$Impl.run%s(this,%d,args);}", 
                                   async ? std::wstring(ActionInvoker::AsyncActionSuffix_sv).c_str() : _T(""), 
                                   action_info.hash);
        };

        if( in_namespace_action_index.has_value() )
        {
            SO::AppendFormat(functions_text, L"%s  %s: (args)=>%s,\n", 
                                             ( *in_namespace_action_index == 0 ) ? _T("") : _T(",\n"),
                                             action_info.name.c_str(), 
                                             get_function_body(false).c_str());

            SO::AppendFormat(functions_text, L"  %s%s: (args)=>%s", 
                                             action_info.name.c_str(), std::wstring(ActionInvoker::AsyncActionSuffix_sv).c_str(), 
                                             get_function_body(true).c_str());

            ++(*in_namespace_action_index);
        }

        else
        {
            SO::AppendFormat(functions_text, L"%s(args) %s\n", 
                                             action_info.name.c_str(), 
                                             get_function_body(false).c_str());

            SO::AppendFormat(functions_text, L"%s%s(args) %s\n", 
                                             action_info.name.c_str(), std::wstring(ActionInvoker::AsyncActionSuffix_sv).c_str(), 
                                             get_function_body(true).c_str());
        }
    }

    end_namespace_if_necessary();


    // insert a dummy function in the area where the functions will go post-minification
    constexpr wstring_view DummyFunctionText_sv = _T("cspro-replace(){};");

    ReplaceAutogeneratedRegion(js_text, DummyFunctionText_sv, std::wstring(AutogeneratedStart_sv), std::wstring(AutogeneratedEnd_sv));

    // minify the code
    std::wstring js_minified_text = UTF8Convert::UTF8ToWide(CSPro::jsmin(UTF8Convert::WideToUTF8(js_text)));
    SO::MakeTrim(js_minified_text);

    // move the end brace of the class to a new line
    ASSERT(js_minified_text.back() == '}');
    js_minified_text.insert(js_minified_text.end() - 1, '\n');

    SO::MakeTrim(js_minified_text);

    // replace the dummy function with our functions text
    SO::Replace(js_minified_text, DummyFunctionText_sv, functions_text);

    for( const std::wstring& output_filename : output_filenames )
        FileIO::WriteText(output_filename, js_minified_text, false);
}


void ReplaceAutogeneratedRegion(const std::wstring& filename, std::initializer_list<std::wstring> replacement_texts)
{
    std::wstring file_text = FileIO::ReadText(filename);
    SO::Replace(file_text, L"\r\n", L"\n");

    size_t block_counter = 0;

    for( const std::wstring& replacement_text : replacement_texts )
    {
        std::wstring autogenerated_start_text(AutogeneratedStart_sv);
        std::wstring autogenerated_end_text(AutogeneratedEnd_sv);

        if( replacement_texts.size() > 1 )
        {
            std::wstring block_suffix = FormatTextCS2WS(L"_%d", ++block_counter);
            autogenerated_start_text.append(block_suffix);
            autogenerated_end_text.append(block_suffix);
        }

        ReplaceAutogeneratedRegion(file_text, replacement_text, autogenerated_start_text, autogenerated_end_text);
    }

    SO::Replace(file_text, L"\n", L"\r\n");
    FileIO::WriteText(filename, file_text, true);
}


void ReplaceAutogeneratedRegion(std::wstring& file_text, std::wstring replacement_text, const std::wstring& autogenerated_start_text, const std::wstring& autogenerated_end_text)
{
    const size_t start_pos = file_text.find(autogenerated_start_text);

    if( start_pos == std::wstring::npos )
        throw CSProException(L"The autogenerated start cannot be found: " + autogenerated_start_text);

    const size_t end_pos = file_text.find(autogenerated_end_text, start_pos + autogenerated_start_text.length());

    if( end_pos == std::wstring::npos )
        throw CSProException(L"The autogenerated end cannot be found: " + autogenerated_end_text);

    // move the start position to the next line and the end position to the previous line
    auto start_itr = file_text.begin() + start_pos;
    auto end_itr = file_text.begin() + end_pos;

    while( start_itr < end_itr && *start_itr != '\n' )
        ++start_itr;

    while( end_itr > start_itr && *end_itr != '\n' )
        --end_itr;

    // add newlines to space out the content from the autogenerated markers
    replacement_text.insert(0, 2, '\n');

    if( replacement_text.back() != '\n' )
        replacement_text.push_back('\n');

    // replace the text
    file_text.replace(start_itr, end_itr, replacement_text);
}
